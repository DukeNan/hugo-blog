---
title: "æ·±å…¥ç†è§£ Golang è°ƒåº¦å™¨ä¹‹ GMP æ¨¡å‹"
date: 2026-02-28T15:10:49+08:00
description: "æ·±å…¥è§£æ Go è¯­è¨€è°ƒåº¦å™¨çš„ GMP æ¨¡å‹ï¼Œç†è§£ Goroutine å¦‚ä½•é«˜æ•ˆè°ƒåº¦ã€M:N çº¿ç¨‹æ¨¡å‹çš„å®ç°åŸç†ï¼Œä»¥åŠè°ƒåº¦ç­–ç•¥å’Œæ€§èƒ½ä¼˜åŒ–æŠ€å·§"
author: "shaun"
featured: true
draft: false
toc: false
usePageBundles: false
codeMaxLines: 10
codeLineNumbers: false
figurePositionShow: true
categories:
  - Technology
tags:
  - Golang
  - Go
---

Go è¯­è¨€èƒ½å¤Ÿè½»æ¾æ”¯æŒæˆåƒä¸Šä¸‡çš„å¹¶å‘ Goroutineï¼Œè¿™èƒŒåçš„ç§˜å¯†å°±åœ¨äºå…¶é«˜æ•ˆçš„è°ƒåº¦å™¨ã€‚**GMP æ¨¡å‹**æ˜¯ Go è°ƒåº¦å™¨çš„æ ¸å¿ƒè®¾è®¡ï¼Œå®ƒå®ç°äº†è½»é‡çº§çš„ç”¨æˆ·æ€çº¿ç¨‹è°ƒåº¦ï¼Œè®© Go ç¨‹åºèƒ½å¤Ÿå……åˆ†å‘æŒ¥å¤šæ ¸ CPU çš„æ€§èƒ½ã€‚æœ¬æ–‡å°†æ·±å…¥å‰–æ GMP æ¨¡å‹çš„è®¾è®¡ç†å¿µã€æ ¸å¿ƒç»„ä»¶ã€è°ƒåº¦ç­–ç•¥ä»¥åŠå®æˆ˜ä¼˜åŒ–æŠ€å·§ã€‚

<!-- more -->

## ç®€ä»‹

### ä»€ä¹ˆæ˜¯ GMP æ¨¡å‹

GMP æ¨¡å‹æ˜¯ Go è¯­è¨€è¿è¡Œæ—¶è°ƒåº¦å™¨çš„æ ¸å¿ƒè®¾è®¡ï¼Œå®ƒå®šä¹‰äº†ä¸‰ç§åŸºæœ¬ç»„ä»¶ï¼š

| ç»„ä»¶ | å…¨ç§° | è¯´æ˜ |
|------|------|------|
| **G** | Goroutine | åç¨‹ï¼ŒGo ä¸­çš„è½»é‡çº§çº¿ç¨‹ |
| **M** | Machine | æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œç”± OS è°ƒåº¦ |
| **P** | Processor | é€»è¾‘å¤„ç†å™¨ï¼ŒåŒ…å«è¿è¡Œ G æ‰€éœ€çš„èµ„æº |

### ä¸ºä»€ä¹ˆéœ€è¦ GMP æ¨¡å‹

åœ¨æ“ä½œç³»ç»Ÿå±‚é¢ï¼Œçº¿ç¨‹æ˜¯è°ƒåº¦çš„åŸºæœ¬å•ä½ï¼Œä½†çº¿ç¨‹å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š

```mermaid
graph TD
    A[çº¿ç¨‹é—®é¢˜] --> B[åˆ›å»ºæˆæœ¬é«˜<br/>çº¦ 1MB æ ˆç©ºé—´]
    A --> C[åˆ‡æ¢å¼€é”€å¤§<br/>ç”¨æˆ·æ€/å†…æ ¸æ€åˆ‡æ¢]
    A --> D[è°ƒåº¦æ•ˆç‡ä½<br/>OS è°ƒåº¦å™¨ä¸äº†è§£ä¸šåŠ¡]
```

Go çš„è§£å†³æ–¹æ¡ˆæ˜¯ **M:N çº¿ç¨‹æ¨¡å‹**ï¼š

- **M ä¸ª Goroutine** æ˜ å°„åˆ° **N ä¸ª OS çº¿ç¨‹**
- Goroutine æ˜¯ç”¨æˆ·æ€çº¿ç¨‹ï¼Œç”± Go è¿è¡Œæ—¶è°ƒåº¦
- åˆ›å»ºæˆæœ¬ä½ï¼ˆåˆå§‹ 2KB æ ˆç©ºé—´ï¼‰ï¼Œåˆ‡æ¢å¼€é”€å°

### GMP æ¨¡å‹çš„è®¾è®¡ç›®æ ‡

| ç›®æ ‡ | è¯´æ˜ |
|------|------|
| **è½»é‡çº§** | Goroutine åˆ›å»ºæˆæœ¬ä½ï¼Œå¯ä»¥åˆ›å»ºå¤§é‡åç¨‹ |
| **é«˜æ•ˆè°ƒåº¦** | ç”¨æˆ·æ€è°ƒåº¦ï¼Œé¿å…é¢‘ç¹çš„å†…æ ¸æ€åˆ‡æ¢ |
| **å¤šæ ¸åˆ©ç”¨** | åˆ©ç”¨å¤šæ ¸ CPUï¼Œå®ç°çœŸæ­£çš„å¹¶è¡Œæ‰§è¡Œ |
| **å…¬å¹³è°ƒåº¦** | æ¯ä¸ª Goroutine éƒ½æœ‰æœºä¼šæ‰§è¡Œï¼Œé¿å…é¥¥é¥¿ |
| **æ‰©å±•æ€§å¥½** | éšç€æ ¸å¿ƒæ•°å¢åŠ ï¼Œæ€§èƒ½çº¿æ€§æå‡ |

## GMP æ ¸å¿ƒç»„ä»¶è¯¦è§£

### G - Goroutine

Goroutine æ˜¯ Go ä¸­çš„å¹¶å‘æ‰§è¡Œå•å…ƒï¼Œæ¯ä¸ª Goroutine å¯¹åº”ä¸€ä¸ª G ç»“æ„ä½“ã€‚

```go
// G çš„æ ¸å¿ƒå­—æ®µï¼ˆç®€åŒ–ç‰ˆï¼‰
type g struct {
    stack       stack    // æ ˆå†…å­˜èŒƒå›´ [lo, hi)
    sched       gobuf    // ä¿å­˜è°ƒåº¦ä¸Šä¸‹æ–‡ï¼ˆPCã€SP ç­‰ï¼‰
    gopc        uintptr  // åˆ›å»ºè¯¥ G çš„ PC
    status      uint32   // çŠ¶æ€ï¼š_Gidle, _Grunnable, _Grunning ç­‰
    goid        int64    // Goroutine ID
    m           *m       // å½“å‰ç»‘å®šçš„ M
    waitreason  string   // ç­‰å¾…åŸå› 
}
```

**G çš„çŠ¶æ€æµè½¬ï¼š**

```mermaid
stateDiagram-v2
    [*] --> _Gidle: æ–°åˆ›å»º
    _Gidle --> _Grunnable: æ”¾å…¥è¿è¡Œé˜Ÿåˆ—
    _Grunnable --> _Grunning: è¢« M æ‰§è¡Œ
    _Grunning --> _Gwaiting: ç³»ç»Ÿè°ƒç”¨/Channel ç­‰
    _Gwaiting --> _Grunnable: ç­‰å¾…ç»“æŸ
    _Grunning --> _Grunnable: æ—¶é—´ç‰‡ç”¨å®Œ/æŠ¢å 
    _Grunning --> *_Gdead: æ‰§è¡Œå®Œæ¯•
    _Gdead --> [*]: å›æ”¶
```

**G çš„çŠ¶æ€è¯´æ˜ï¼š**

| çŠ¶æ€ | è¯´æ˜ |
|------|------|
| `_Gidle` | åˆšåˆ›å»ºï¼Œå°šæœªåˆå§‹åŒ– |
| `_Grunnable` | åœ¨è¿è¡Œé˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…è¿è¡Œ |
| `_Grunning` | æ­£åœ¨æ‰§è¡Œ |
| `_Gwaiting` | è¢«é˜»å¡ï¼ˆå¦‚ Channelã€IOã€é”ç­‰ï¼‰ |
| `_Gsyscall` | æ­£åœ¨æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ |
| `_Gdead` | æ‰§è¡Œå®Œæ¯•ï¼Œç­‰å¾…å›æ”¶ |

### M - Machine

M æ˜¯æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„æŠ½è±¡ï¼Œä»£è¡¨ä¸€ä¸ªçœŸæ­£çš„æ‰§è¡Œçº¿ç¨‹ã€‚

```go
// M çš„æ ¸å¿ƒå­—æ®µï¼ˆç®€åŒ–ç‰ˆï¼‰
type m struct {
    g0       *g      // ç‰¹æ®Šçš„ Gï¼Œç”¨äºæ‰§è¡Œè°ƒåº¦ä»£ç 
    curg     *g      // å½“å‰è¿è¡Œçš„ G
    p        *p      // ç»‘å®šçš„ P
    nextp    *p      // å³å°†ç»‘å®šçš„ P
    spinning bool    // æ˜¯å¦å¤„äºè‡ªæ—‹çŠ¶æ€ï¼ˆæ­£åœ¨å¯»æ‰¾ Gï¼‰
    blocked  bool    // æ˜¯å¦è¢«é˜»å¡
    park     note    // ä¼‘çœ å”¤é†’æœºåˆ¶
}
```

**M çš„ç‰¹ç‚¹ï¼š**

- M æ˜¯çœŸæ­£çš„ OS çº¿ç¨‹ï¼Œç”±æ“ä½œç³»ç»Ÿè°ƒåº¦
- æ¯ä¸ª M éƒ½æœ‰ä¸€ä¸ªç‰¹æ®Šçš„ `g0`ï¼Œç”¨äºæ‰§è¡Œè°ƒåº¦ä»£ç 
- M éœ€è¦ç»‘å®š P æ‰èƒ½æ‰§è¡Œ G
- M çš„æ•°é‡å¯ä»¥åŠ¨æ€å¢å‡

**g0 çš„ä½œç”¨ï¼š**

```mermaid
graph LR
    subgraph M
        g0[g0<br/>è°ƒåº¦æ ˆ]
        curg[curg<br/>ç”¨æˆ· G]
    end

    g0 -->|è°ƒåº¦| curg
    curg -->|ä¿å­˜ä¸Šä¸‹æ–‡| g0
```

- `g0` ä½¿ç”¨ç³»ç»Ÿæ ˆï¼ˆçº¦ 8KBï¼‰ï¼Œç”¨äºæ‰§è¡Œè°ƒåº¦ã€ç³»ç»Ÿè°ƒç”¨ç­‰
- ç”¨æˆ· G ä½¿ç”¨è‡ªå·±çš„æ ˆï¼ˆåˆå§‹ 2KBï¼Œå¯å¢é•¿ï¼‰
- è°ƒåº¦æ—¶ä¼šåˆ‡æ¢åˆ° `g0` æ ˆæ‰§è¡Œ

### P - Processor

P æ˜¯é€»è¾‘å¤„ç†å™¨ï¼ŒæŒæœ‰è¿è¡Œ G æ‰€éœ€çš„èµ„æºï¼ˆå¦‚æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ï¼‰ã€‚

```go
// P çš„æ ¸å¿ƒå­—æ®µï¼ˆç®€åŒ–ç‰ˆï¼‰
type p struct {
    id          int32       // P çš„ ID
    status      uint32      // çŠ¶æ€ï¼š_Pidle, _Prunning ç­‰
    m           *m          // ç»‘å®šçš„ M
    runqhead    uint32      // æœ¬åœ°è¿è¡Œé˜Ÿåˆ—å¤´
    runqtail    uint32      // æœ¬åœ°è¿è¡Œé˜Ÿåˆ—å°¾
    runq        [256]*g     // æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ï¼ˆç¯å½¢é˜Ÿåˆ—ï¼‰
    runnext     *g          // ä¼˜å…ˆè¿è¡Œçš„ G
    gFree       *g          // ç©ºé—² G åˆ—è¡¨ï¼ˆå¤ç”¨ï¼‰
    gcBgMarkWorker *g       // GC åå°æ ‡è®° Worker
}
```

**P çš„çŠ¶æ€ï¼š**

| çŠ¶æ€ | è¯´æ˜ |
|------|------|
| `_Pidle` | ç©ºé—²ï¼Œæœªç»‘å®š M |
| `_Prunning` | è¿è¡Œä¸­ï¼Œå·²ç»‘å®š M |
| `_Psyscall` | M æ­£åœ¨æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ |
| `_Pgcstop` | GC æœŸé—´åœæ­¢ |
| `_Pdead` | ä¸å†ä½¿ç”¨ |

**P çš„ä½œç”¨ï¼š**

1. **æœ¬åœ°è¿è¡Œé˜Ÿåˆ—**ï¼šæ¯ä¸ª P æœ‰ä¸€ä¸ªæœ¬åœ°é˜Ÿåˆ—ï¼ˆæœ€å¤š 256 ä¸ª Gï¼‰
2. **èµ„æºéš”ç¦»**ï¼šP æŒæœ‰è¿è¡Œ G æ‰€éœ€çš„èµ„æºï¼Œå‡å°‘é”ç«äº‰
3. **å·¥ä½œçªƒå–**ï¼šP ä¹‹é—´å¯ä»¥çªƒå– Gï¼Œå®ç°è´Ÿè½½å‡è¡¡

### GMP çš„å…³ç³»

```mermaid
graph TB
    subgraph å…¨å±€è¿è¡Œé˜Ÿåˆ—
        GRQ[G åˆ—è¡¨]
    end

    subgraph P0
        LRQ0[æœ¬åœ°é˜Ÿåˆ—<br/>256 G]
        P0Node[P0]
    end

    subgraph P1
        LRQ1[æœ¬åœ°é˜Ÿåˆ—<br/>256 G]
        P1Node[P1]
    end

    subgraph M0[æ“ä½œç³»ç»Ÿçº¿ç¨‹ M0]
        g0_0[g0]
        G0[G]
    end

    subgraph M1[æ“ä½œç³»ç»Ÿçº¿ç¨‹ M1]
        g0_1[g0]
        G1[G]
    end

    GRQ --> LRQ0
    GRQ --> LRQ1
    P0Node --> M0
    P1Node --> M1
```

**æ ¸å¿ƒå…³ç³»ï¼š**

- ä¸€ä¸ª M å¿…é¡»ç»‘å®šä¸€ä¸ª P æ‰èƒ½æ‰§è¡Œ G
- ä¸€ä¸ª P åœ¨åŒä¸€æ—¶åˆ»åªèƒ½ç»‘å®šä¸€ä¸ª M
- P çš„æ•°é‡é»˜è®¤ç­‰äº CPU æ ¸å¿ƒæ•°ï¼ˆ`GOMAXPROCS`ï¼‰
- M çš„æ•°é‡å¯ä»¥å¤§äº P çš„æ•°é‡ï¼ˆå¤„ç†ç³»ç»Ÿè°ƒç”¨ï¼‰

## è°ƒåº¦å™¨å·¥ä½œåŸç†

### è°ƒåº¦å¾ªç¯

M çš„æ‰§è¡Œè¿‡ç¨‹æ˜¯ä¸€ä¸ªå¾ªç¯ï¼š**æ‰¾ G â†’ æ‰§è¡Œ G â†’ ä¿å­˜ä¸Šä¸‹æ–‡ â†’ æ‰¾ä¸‹ä¸€ä¸ª G**ã€‚

```mermaid
sequenceDiagram
    participant M
    participant P
    participant G

    loop è°ƒåº¦å¾ªç¯
        M->>P: æŸ¥æ‰¾å¯è¿è¡Œçš„ G
        alt æœ¬åœ°é˜Ÿåˆ—æœ‰ G
            P-->>M: è¿”å› G
        else æœ¬åœ°é˜Ÿåˆ—ç©º
            M->>P: ä»å…¨å±€é˜Ÿåˆ—/å…¶ä»– P çªƒå–
            P-->>M: è¿”å› G
        end
        M->>G: æ‰§è¡Œ G
        G->>M: æ—¶é—´ç‰‡ç”¨å®Œ/é˜»å¡/å®Œæˆ
        M->>G: ä¿å­˜ä¸Šä¸‹æ–‡ï¼ˆPCã€SPï¼‰
    end
```

### æŸ¥æ‰¾ G çš„é¡ºåº

è°ƒåº¦å™¨æŒ‰ä»¥ä¸‹ä¼˜å…ˆçº§æŸ¥æ‰¾å¯è¿è¡Œçš„ Gï¼š

```mermaid
flowchart TD
    A[å¼€å§‹æŸ¥æ‰¾] --> B{runnext != nil?}
    B -->|æ˜¯| C[è¿”å› runnext]
    B -->|å¦| D{æœ¬åœ°é˜Ÿåˆ—ç©º?}
    D -->|å¦| E[ä»æœ¬åœ°é˜Ÿåˆ—å– G]
    D -->|æ˜¯| F{å…¨å±€é˜Ÿåˆ—ç©º?}
    F -->|å¦| G[ä»å…¨å±€é˜Ÿåˆ—å– G]
    F -->|æ˜¯| H{ç½‘ç»œè½®è¯¢å™¨æœ‰ G?}
    H -->|æ˜¯| I[ä»ç½‘ç»œè½®è¯¢å™¨å– G]
    H -->|å¦| J[ä»å…¶ä»– P çªƒå– G]
    E --> K[è¿”å› G]
    G --> K
    I --> K
    J --> K
    C --> K
```

**è¯¦ç»†è¯´æ˜ï¼š**

1. **runnext**ï¼šæœ€è¿‘åˆ›å»ºçš„ Gï¼Œä¼˜å…ˆçº§æœ€é«˜
2. **æœ¬åœ°é˜Ÿåˆ—**ï¼šå½“å‰ P çš„æœ¬åœ°é˜Ÿåˆ—ï¼Œæ— é”è®¿é—®
3. **å…¨å±€é˜Ÿåˆ—**ï¼šæ‰€æœ‰ P å…±äº«ï¼Œéœ€è¦åŠ é”
4. **ç½‘ç»œè½®è¯¢å™¨**ï¼šç½‘ç»œ IO å°±ç»ªçš„ G
5. **å·¥ä½œçªƒå–**ï¼šä»å…¶ä»– P çš„æœ¬åœ°é˜Ÿåˆ—çªƒå–ä¸€åŠ

### è°ƒåº¦æ—¶æœº

ä»¥ä¸‹æƒ…å†µä¼šè§¦å‘è°ƒåº¦ï¼š

| è§¦å‘ç‚¹ | è¯´æ˜ |
|--------|------|
| `go func()` | åˆ›å»ºæ–°çš„ Goroutine |
| `time.Sleep` | Goroutine ä¼‘çœ  |
| `channel` æ“ä½œ | å‘é€/æ¥æ”¶é˜»å¡ |
| `select` | å¤šè·¯å¤ç”¨é˜»å¡ |
| `sync.Mutex` | é”ç«äº‰é˜»å¡ |
| `runtime.Gosched()` | ä¸»åŠ¨è®©å‡º CPU |
| ç³»ç»Ÿè°ƒç”¨ | è¿›å…¥/é€€å‡ºç³»ç»Ÿè°ƒç”¨ |
| æŠ¢å å¼è°ƒåº¦ | GC æˆ–ç›‘æ§çº¿ç¨‹æŠ¢å  |

### ä¸Šä¸‹æ–‡åˆ‡æ¢

å½“ G è¢«åˆ‡æ¢å‡ºå»æ—¶ï¼Œéœ€è¦ä¿å­˜å…¶æ‰§è¡Œä¸Šä¸‹æ–‡ï¼š

```go
// gobuf ä¿å­˜ G çš„è°ƒåº¦ä¿¡æ¯
type gobuf struct {
    sp   uintptr  // æ ˆæŒ‡é’ˆ
    pc   uintptr  // ç¨‹åºè®¡æ•°å™¨
    g    guintptr // æŒ‡å‘ G
    ret  uintptr  // è¿”å›å€¼
}
```

**åˆ‡æ¢è¿‡ç¨‹ï¼š**

```mermaid
sequenceDiagram
    participant G1
    participant g0
    participant Scheduler
    participant G2

    G1->>g0: ä¿å­˜ä¸Šä¸‹æ–‡ï¼ˆSP, PCï¼‰
    g0->>Scheduler: æŸ¥æ‰¾ä¸‹ä¸€ä¸ª G
    Scheduler->>g0: è¿”å› G2
    g0->>G2: æ¢å¤ä¸Šä¸‹æ–‡å¹¶æ‰§è¡Œ
```

## è°ƒåº¦ç­–ç•¥è¯¦è§£

### å·¥ä½œçªƒå–ï¼ˆWork Stealingï¼‰

å½“æœ¬åœ°é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼ŒP ä¼šå°è¯•ä»å…¶ä»– P çªƒå– Gã€‚

```mermaid
graph LR
    subgraph P0
        Q0[G1, G2, G3, G4]
    end

    subgraph P1
        Q1[ç©º]
    end

    P1 -->|çªƒå–ä¸€åŠ| P0
    Q0 -.->|G1, G2| Q1
```

**çªƒå–è§„åˆ™ï¼š**

- ä»å…¶ä»– P çš„æœ¬åœ°é˜Ÿåˆ—å°¾éƒ¨çªƒå–ä¸€åŠï¼ˆæœ€å¤š 32 ä¸ªï¼‰
- éšæœºé€‰æ‹©ä¸€ä¸ª P å¼€å§‹å°è¯•
- å¦‚æœçªƒå–å¤±è´¥ï¼Œç»§ç»­å°è¯•å…¶ä»– P
- æ‰€æœ‰ P éƒ½çªƒå–å¤±è´¥åï¼Œæ£€æŸ¥å…¨å±€é˜Ÿåˆ—å’Œç½‘ç»œè½®è¯¢å™¨

### ç³»ç»Ÿè°ƒç”¨å¤„ç†

å½“ M æ‰§è¡Œç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œä¼šé˜»å¡ OS çº¿ç¨‹ã€‚Go çš„å¤„ç†ç­–ç•¥æ˜¯ **Hand off** æœºåˆ¶ã€‚

```mermaid
sequenceDiagram
    participant M1
    participant P1
    participant Syscall
    participant M2
    participant Scheduler

    M1->>P1: è¿›å…¥ç³»ç»Ÿè°ƒç”¨å‰
    Note over P1: P1 çŠ¶æ€å˜ä¸º _Psyscall
    M1->>Syscall: æ‰§è¡Œé˜»å¡çš„ç³»ç»Ÿè°ƒç”¨

    alt ç³»ç»Ÿè°ƒç”¨æ—¶é—´è¾ƒé•¿
        Scheduler->>M2: å”¤é†’æˆ–åˆ›å»ºæ–° M
        M2->>P1: ä» M1 æ¥ç®¡ P1
        M2->>P1: P1 çŠ¶æ€å˜ä¸º _Prunning
    end

    Syscall-->>M1: ç³»ç»Ÿè°ƒç”¨è¿”å›
    M1->>P1: å°è¯•å–å› P1

    alt P1 å·²è¢«å…¶ä»– M æ¥ç®¡
        M1->>Scheduler: å°è¯•è·å–ç©ºé—² P
        alt æœ‰ç©ºé—² P
            M1->>Scheduler: ç»‘å®šç©ºé—² Pï¼Œç»§ç»­æ‰§è¡Œ
        else æ— ç©ºé—² P
            M1->>Scheduler: ä¼‘çœ æˆ–é”€æ¯
        end
    end
```

**å…³é”®ç‚¹ï¼š**

1. **è¿›å…¥ç³»ç»Ÿè°ƒç”¨**ï¼šM é‡Šæ”¾ Pï¼ŒP è¿›å…¥ `_Psyscall` çŠ¶æ€
2. **ç³»ç»Ÿè°ƒç”¨æœŸé—´**ï¼šå…¶ä»– M å¯ä»¥æ¥ç®¡ Pï¼Œç»§ç»­æ‰§è¡Œå…¶ä»– G
3. **é€€å‡ºç³»ç»Ÿè°ƒç”¨**ï¼šM å°è¯•å–å›åŸæ¥çš„ Pï¼Œæˆ–è·å–å…¶ä»–ç©ºé—² P

### æŠ¢å å¼è°ƒåº¦

Go 1.14 å¼•å…¥äº†åŸºäºä¿¡å·çš„å¼‚æ­¥æŠ¢å ï¼Œè§£å†³äº†é•¿æ—¶é—´è¿è¡Œçš„ G é¥¿æ­»å…¶ä»– G çš„é—®é¢˜ã€‚

**æŠ¢å è§¦å‘æ¡ä»¶ï¼š**

1. **GC æ ˆæ‰«æ**ï¼šå‘ç° G è¿è¡Œæ—¶é—´è¶…è¿‡ 10ms
2. **ç³»ç»Ÿç›‘æ§**ï¼šå‘ç° G è¿è¡Œæ—¶é—´è¿‡é•¿
3. **å†…å­˜åˆ†é…**ï¼šå†…å­˜åˆ†é…å¤±è´¥éœ€è¦è§¦å‘ GC

**æŠ¢å æµç¨‹ï¼š**

```mermaid
sequenceDiagram
    participant Monitor
    participant M
    participant G
    participant g0

    Monitor->>M: å‘é€ SIGURG ä¿¡å·
    M->>G: ä¿¡å·å¤„ç†å‡½æ•°
    G->>g0: åˆ‡æ¢åˆ° g0 æ ˆ
    g0->>g0: ä¿å­˜ G çš„ä¸Šä¸‹æ–‡
    g0->>g0: å°† G æ”¾å…¥å…¨å±€é˜Ÿåˆ—
    g0->>g0: è°ƒåº¦ä¸‹ä¸€ä¸ª G
```

### å…¬å¹³è°ƒåº¦

Go è°ƒåº¦å™¨é€šè¿‡ä»¥ä¸‹æœºåˆ¶ä¿è¯å…¬å¹³æ€§ï¼š

| æœºåˆ¶ | è¯´æ˜ |
|------|------|
| **æ—¶é—´ç‰‡è½®è½¬** | æ¯ä¸ª G æœ€å¤šè¿ç»­æ‰§è¡Œ 10ms |
| **æŠ¢å å¼è°ƒåº¦** | é•¿æ—¶é—´è¿è¡Œçš„ G ä¼šè¢«æŠ¢å  |
| **å…¨å±€é˜Ÿåˆ—ä¼˜å…ˆ** | æ¯ 61 æ¬¡è°ƒåº¦ä»å…¨å±€é˜Ÿåˆ—å– G |
| **å·¥ä½œçªƒå–** | è´Ÿè½½ä¸å‡æ—¶è‡ªåŠ¨å¹³è¡¡ |

```go
// ç®€åŒ–çš„è°ƒåº¦ä»£ç 
func schedule() {
    // æ¯ 61 æ¬¡è°ƒåº¦ï¼Œä¼˜å…ˆä»å…¨å±€é˜Ÿåˆ—å– G
    if schedCount%61 == 0 {
        if gp := globrunqget(_p_, 1); gp != nil {
            return gp
        }
    }
    // ...
}
```

## è°ƒåº¦å™¨ç”Ÿå‘½å‘¨æœŸ

### å¯åŠ¨è¿‡ç¨‹

```mermaid
sequenceDiagram
    participant Runtime
    participant Scheduler
    participant P
    participant M

    Runtime->>Scheduler: åˆå§‹åŒ–è°ƒåº¦å™¨
    Runtime->>P: åˆ›å»º GOMAXPROCS ä¸ª P
    Runtime->>M: åˆ›å»ºåˆå§‹ Mï¼ˆM0ï¼‰
    M->>P: M0 ç»‘å®š P0
    Runtime->>Scheduler: åˆ›å»ºä¸» Goroutine
    Scheduler->>P: å°†ä¸» G æ”¾å…¥ P0 çš„é˜Ÿåˆ—
    M->>Scheduler: å¼€å§‹è°ƒåº¦å¾ªç¯
```

### Goroutine åˆ›å»º

```go
// go func() çš„å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
func newproc(fn *funcval) {
    // 1. ä» P çš„ç©ºé—²åˆ—è¡¨è·å– Gï¼Œæˆ–æ–°å»º G
    gp := gfget(_p_)
    if gp == nil {
        gp = malg(_StackMin)  // åˆ†é… 2KB æ ˆ
    }

    // 2. åˆå§‹åŒ– G
    gp.sched.pc = fn.pc
    gp.sched.sp = gp.stack.hi

    // 3. æ”¾å…¥è¿è¡Œé˜Ÿåˆ—
    runqput(_p_, gp, true)  // true è¡¨ç¤ºæ”¾å…¥ runnext
}
```

### Goroutine ç»“æŸ

```mermaid
stateDiagram-v2
    [*] --> æ‰§è¡Œä¸­
    æ‰§è¡Œä¸­ --> å‡†å¤‡ç»“æŸ: return/panic/recover
    å‡†å¤‡ç»“æŸ --> åˆ‡æ¢åˆ°g0: gogo(&g0.sched)
    åˆ‡æ¢åˆ°g0 --> æ¸…ç†ç°åœº: goexit0(gp)
    æ¸…ç†ç°åœº --> å›æ”¶èµ„æº: è§£é™¤ç»‘å®šã€æ¸…ç©ºå­—æ®µ
    å›æ”¶èµ„æº --> æ”¾å…¥ç©ºé—²åˆ—è¡¨: gfput(_p_, gp)
    æ”¾å…¥ç©ºé—²åˆ—è¡¨ --> [*]
```

## å®æˆ˜åˆ†æ

### æŸ¥çœ‹è°ƒåº¦ä¿¡æ¯

ä½¿ç”¨ `GODEBUG` ç¯å¢ƒå˜é‡å¯ä»¥æŸ¥çœ‹è°ƒåº¦å™¨çš„è¯¦ç»†ä¿¡æ¯ï¼š

```bash
# æ˜¾ç¤ºè°ƒåº¦å™¨è¯¦ç»†ä¿¡æ¯
GODEBUG=schedtrace=1000 ./myprogram

# è¾“å‡ºç¤ºä¾‹
SCHED 1000ms: gomaxprocs=8 idleprocs=0 threads=10 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0]
```

**è¾“å‡ºè§£é‡Šï¼š**

| å­—æ®µ | è¯´æ˜ |
|------|------|
| `gomaxprocs` | P çš„æ•°é‡ |
| `idleprocs` | ç©ºé—² P çš„æ•°é‡ |
| `threads` | M çš„æ•°é‡ |
| `spinningthreads` | è‡ªæ—‹ M çš„æ•°é‡ |
| `idlethreads` | ç©ºé—² M çš„æ•°é‡ |
| `runqueue` | å…¨å±€é˜Ÿåˆ—ä¸­çš„ G æ•°é‡ |
| `[...]` | æ¯ä¸ª P çš„æœ¬åœ°é˜Ÿåˆ—ä¸­çš„ G æ•°é‡ |

### ä½¿ç”¨ pprof åˆ†æ

```go
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()

    // ä½ çš„ç¨‹åº...
}
```

```bash
# æŸ¥çœ‹ Goroutine æ•°é‡å’ŒçŠ¶æ€
curl http://localhost:6060/debug/pprof/goroutine?debug=1

# ä½¿ç”¨ go tool pprof åˆ†æ
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

### è¿½è¸ªè°ƒåº¦äº‹ä»¶

ä½¿ç”¨ `runtime/trace` åŒ…è¿½è¸ªè°ƒåº¦äº‹ä»¶ï¼š

```go
import (
    "runtime/trace"
    "os"
)

func main() {
    f, _ := os.Create("trace.out")
    defer f.Close()

    trace.Start(f)
    defer trace.Stop()

    // ä½ çš„ç¨‹åº...
}
```

```bash
# ç”Ÿæˆè¿½è¸ªæ–‡ä»¶åï¼Œä½¿ç”¨ go tool trace åˆ†æ
go tool trace trace.out
```

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. åˆç†è®¾ç½® GOMAXPROCS

```go
// é»˜è®¤ç­‰äº CPU æ ¸å¿ƒæ•°
// åœ¨å®¹å™¨ç¯å¢ƒä¸­å¯èƒ½éœ€è¦æ‰‹åŠ¨è®¾ç½®
import "runtime"

func init() {
    runtime.GOMAXPROCS(4)  // è®¾ç½®ä¸º 4 ä¸ª P
}
```

{{% notice note "æ³¨æ„ğŸ“¢" %}}
åœ¨ Kubernetes å®¹å™¨ç¯å¢ƒä¸­ï¼Œ`GOMAXPROCS` é»˜è®¤ç­‰äºå®¿ä¸»æœºçš„ CPU æ ¸å¿ƒæ•°ï¼Œå¯èƒ½å¯¼è‡´ä¸¥é‡çš„ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ã€‚å»ºè®®ä½¿ç”¨ `automaxprocs` åº“è‡ªåŠ¨è·å–å®¹å™¨çš„ CPU é™åˆ¶ã€‚
{{% /notice %}}

```go
// ä½¿ç”¨ automaxprocs è‡ªåŠ¨è®¾ç½®
import _ "go.uber.org/automaxprocs"
```

### 2. é¿å… Goroutine æ³„æ¼

```go
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šGoroutine æ³„æ¼
func leak() {
    ch := make(chan int)
    go func() {
        <-ch  // æ°¸è¿œé˜»å¡ï¼Œå› ä¸ºæ²¡æœ‰äººå‘é€æ•°æ®
    }()
    // å‡½æ•°è¿”å›ï¼Œä½† Goroutine ä»åœ¨è¿è¡Œ
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨ context å–æ¶ˆ
func noLeak(ctx context.Context) {
    ch := make(chan int)
    go func() {
        select {
        case <-ch:
            // å¤„ç†æ•°æ®
        case <-ctx.Done():
            return  // æå‰é€€å‡º
        }
    }()
}
```

### 3. æ§åˆ¶å¹¶å‘æ•°é‡

```go
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šæ— é™åˆ¶åˆ›å»º Goroutine
func processAll(items []Item) {
    for _, item := range items {
        go process(item)  // å¯èƒ½åˆ›å»ºæ•°ç™¾ä¸‡ä¸ª Goroutine
    }
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨å·¥ä½œæ± 
func processAll(items []Item, workers int) {
    sem := make(chan struct{}, workers)
    var wg sync.WaitGroup

    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()
            sem <- struct{}{}  // è·å–ä¿¡å·é‡
            defer func() { <-sem }()  // é‡Šæ”¾ä¿¡å·é‡
            process(item)
        }(item)
    }
    wg.Wait()
}
```

### 4. é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯ Goroutine

```go
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šæ¯æ¬¡è¯·æ±‚åˆ›å»ºæ–° Goroutine
func handleRequest(req Request) {
    go func() {
        process(req)
    }()
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨ Goroutine æ± 
var pool = &sync.Pool{
    New: func() interface{} {
        return new(Worker)
    },
}

func handleRequest(req Request) {
    w := pool.Get().(*Worker)
    defer pool.Put(w)
    w.process(req)
}
```

### 5. é¿å…åœ¨å¾ªç¯ä¸­åˆ›å»ºé—­åŒ…

```go
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šæ‰€æœ‰ Goroutine æ•è·åŒä¸€ä¸ªå˜é‡
for i := 0; i < 10; i++ {
    go func() {
        fmt.Println(i)  // å¯èƒ½å…¨éƒ¨æ‰“å° 10
    }()
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä¼ é€’å‚æ•°
for i := 0; i < 10; i++ {
    go func(n int) {
        fmt.Println(n)
    }(i)
}
```

### 6. ä½¿ç”¨ sync.WaitGroup ç­‰å¾… Goroutine

```go
func processConcurrently(items []Item) error {
    var wg sync.WaitGroup
    errCh := make(chan error, len(items))

    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()
            if err := process(item); err != nil {
                errCh <- err
            }
        }(item)
    }

    wg.Wait()
    close(errCh)

    // è¿”å›ç¬¬ä¸€ä¸ªé”™è¯¯
    for err := range errCh {
        return err
    }
    return nil
}
```

## å¸¸è§é—®é¢˜

### Q1: Goroutine å’Œçº¿ç¨‹çš„åŒºåˆ«

| ç‰¹æ€§ | Goroutine | OS çº¿ç¨‹ |
|------|-----------|---------|
| æ ˆç©ºé—´ | 2KB èµ·ï¼ŒåŠ¨æ€å¢é•¿ | å›ºå®š ~1MB |
| åˆ›å»ºå¼€é”€ | å¾®ç§’çº§ | æ¯«ç§’çº§ |
| åˆ‡æ¢å¼€é”€ | ç”¨æˆ·æ€åˆ‡æ¢ï¼Œçº³ç§’çº§ | å†…æ ¸æ€åˆ‡æ¢ï¼Œå¾®ç§’çº§ |
| è°ƒåº¦å™¨ | Go è¿è¡Œæ—¶ | æ“ä½œç³»ç»Ÿ |
| æ•°é‡é™åˆ¶ | å¯ä»¥åˆ›å»ºæ•°ç™¾ä¸‡ | é€šå¸¸æ•°åƒä¸ª |
| åˆ‡æ¢æ–¹å¼ | åä½œå¼ + æŠ¢å å¼ | æŠ¢å å¼ |

### Q2: å¦‚ä½•æŸ¥çœ‹å½“å‰ Goroutine æ•°é‡

```go
import "runtime"

func main() {
    fmt.Printf("Goroutine æ•°é‡: %d\n", runtime.NumGoroutine())
}
```

### Q3: ä¸ºä»€ä¹ˆéœ€è¦ P

P çš„å¼•å…¥ï¼ˆGo 1.1ï¼‰è§£å†³äº†ä»¥ä¸‹é—®é¢˜ï¼š

1. **èµ„æºéš”ç¦»**ï¼šæ¯ä¸ª P æœ‰ç‹¬ç«‹çš„æœ¬åœ°é˜Ÿåˆ—ï¼Œå‡å°‘é”ç«äº‰
2. **å·¥ä½œçªƒå–**ï¼šå®ç°è´Ÿè½½å‡è¡¡
3. **ç¼“å­˜äº²å’Œæ€§**ï¼šG å€¾å‘äºåœ¨åŒä¸€ä¸ª P ä¸Šè¿è¡Œ

### Q4: å¦‚ä½•åˆ¤æ–­è°ƒåº¦å™¨æ˜¯å¦å¥åº·

è§‚å¯Ÿä»¥ä¸‹æŒ‡æ ‡ï¼š

```bash
# ä½¿ç”¨ GODEBUG æŸ¥çœ‹è°ƒåº¦ä¿¡æ¯
GODEBUG=schedtrace=1000,scheddetail=1 ./myprogram
```

å¥åº·æŒ‡æ ‡ï¼š

| æŒ‡æ ‡ | æ­£å¸¸èŒƒå›´ | å¼‚å¸¸æƒ…å†µ |
|------|----------|----------|
| `runqueue` | 0 æˆ–å¾ˆå° | æŒç»­å¾ˆå¤§ï¼Œè°ƒåº¦å™¨å‹åŠ›å¤§ |
| `idleprocs` | æœ‰ç©ºé—² P | æŒç»­ä¸º 0ï¼ŒCPU ä½¿ç”¨ç‡é«˜ |
| `threads` | åˆç†æ•°é‡ | æŒç»­å¢é•¿ï¼Œå¯èƒ½æœ‰æ³„æ¼ |
| `spinningthreads` | 0 æˆ– 1 | è¿‡é«˜ï¼ŒCPU æµªè´¹ |

### Q5: å¦‚ä½•é¿å…è°ƒåº¦å™¨æŠ–åŠ¨

**åŸå› **ï¼šG é¢‘ç¹åœ¨ä¸åŒ P ä¹‹é—´è¿ç§»ï¼Œå¯¼è‡´ç¼“å­˜å¤±æ•ˆã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

```go
// ä½¿ç”¨ runtime.LockOSThread å°† G ç»‘å®šåˆ°å½“å‰ M
func main() {
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()

    // è¿™æ®µä»£ç å§‹ç»ˆåœ¨åŒä¸€ä¸ª OS çº¿ç¨‹ä¸Šæ‰§è¡Œ
    // é€‚ç”¨äºéœ€è¦çº¿ç¨‹å±€éƒ¨å­˜å‚¨æˆ–ç‰¹å®š CPU äº²å’Œæ€§çš„åœºæ™¯
}
```

## æ€»ç»“

GMP æ¨¡å‹æ˜¯ Go è¯­è¨€é«˜å¹¶å‘èƒ½åŠ›çš„åŸºçŸ³ï¼Œç†è§£å®ƒå¯¹äºç¼–å†™é«˜æ•ˆçš„ Go ç¨‹åºè‡³å…³é‡è¦ã€‚

**æ ¸å¿ƒè¦ç‚¹ï¼š**

- **G (Goroutine)**ï¼šè½»é‡çº§åç¨‹ï¼Œç”¨æˆ·æ€çº¿ç¨‹ï¼Œåˆ›å»ºæˆæœ¬ä½
- **M (Machine)**ï¼šæ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼ŒçœŸæ­£æ‰§è¡Œä»£ç 
- **P (Processor)**ï¼šé€»è¾‘å¤„ç†å™¨ï¼ŒæŒæœ‰è¿è¡Œèµ„æºï¼Œå®ç°å·¥ä½œçªƒå–

**è°ƒåº¦ç­–ç•¥ï¼š**

- **å·¥ä½œçªƒå–**ï¼šè´Ÿè½½å‡è¡¡ï¼ŒP ä¹‹é—´å¯ä»¥çªƒå– G
- **ç³»ç»Ÿè°ƒç”¨å¤„ç†**ï¼šHand off æœºåˆ¶ï¼Œé¿å… M é˜»å¡å½±å“å…¶ä»– G
- **æŠ¢å å¼è°ƒåº¦**ï¼šåŸºäºä¿¡å·çš„å¼‚æ­¥æŠ¢å ï¼Œä¿è¯å…¬å¹³æ€§
- **å…¬å¹³è°ƒåº¦**ï¼šæ—¶é—´ç‰‡è½®è½¬ã€å…¨å±€é˜Ÿåˆ—ä¼˜å…ˆ

**ä¼˜åŒ–å»ºè®®ï¼š**

1. åˆç†è®¾ç½® `GOMAXPROCS`ï¼Œå®¹å™¨ç¯å¢ƒä½¿ç”¨ `automaxprocs`
2. é¿å… Goroutine æ³„æ¼ï¼Œä½¿ç”¨ `context` å–æ¶ˆ
3. æ§åˆ¶å¹¶å‘æ•°é‡ï¼Œä½¿ç”¨å·¥ä½œæ± æˆ–ä¿¡å·é‡
4. é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯ Goroutine
5. æ³¨æ„é—­åŒ…å˜é‡æ•è·é—®é¢˜
6. ä½¿ç”¨ `sync.WaitGroup` ç­‰å¾… Goroutine å®Œæˆ

ç†è§£ GMP æ¨¡å‹çš„å·¥ä½œåŸç†ï¼Œèƒ½å¤Ÿå¸®åŠ©ä½ æ›´å¥½åœ°è¯Šæ–­å’Œè§£å†³ Go ç¨‹åºä¸­çš„å¹¶å‘é—®é¢˜ï¼Œç¼–å†™å‡ºæ›´é«˜æ•ˆçš„å¹¶å‘ä»£ç ã€‚

## å‚è€ƒèµ„æº

- [Go è°ƒåº¦å™¨è®¾è®¡æ–‡æ¡£](https://golang.org/src/runtime/proc.go)
- [Go è°ƒåº¦å™¨è®¾è®¡åŸç†](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw)
- [Go è¯­è¨€è®¾è®¡ä¸å®ç° - è°ƒåº¦å™¨](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)
- [Scalable Go Scheduler Design Doc](https://golang.org/s/go11sched)
